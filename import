#!/usr/bin/env node

var url = require('url'),
    path = require('path'),
    http = require('http'),
    csv = require('fast-csv');

var importer,
    reqOpts,
    flags = {
      dryrun: false,
      ignoreColumns: []
    },
    stats = {rows: 0, requests:0, responses:{}},
    wait = 500, // wait between requests
    self = process.argv[1].split(path.sep).pop();

var supportedTypes = {
  users: {
    required: ['name', 'username', 'password'],
    constraints: {
      unique: ['username']
    }
  },
  people: {
    required: ['uuid','name'],
    constraints: {
      unique: ['uuid']
    },
    doc_type: 'person'
  },
  'places-level-0': {
    required: ['uuid','name'],
    constraints: {
      unique: ['uuid']
    },
    doc_type: 'national_office'
  },
  'places-level-1': {
    required: ['uuid','name'],
    constraints: {
      unique: ['uuid']
    },
    doc_type: 'district_hospital'
  },
  'places-level-2': {
    required: ['uuid','name'],
    constraints: {
      unique: ['uuid']
    },
    doc_type: 'health_center'
  },
  'places-level-3': {
    required: ['uuid','name'],
    constraints: {
      unique: ['uuid']
    },
    doc_type: 'clinic'
  }
};

var outputError = function() {
  var RED = '\033[0;31m';
  var NC = '\033[0m';

  var args = Array.prototype.slice.call(arguments);

  args[0] = RED + arguments[0] + NC;

  console.error.apply(null, args);
};

// requires node >= 4 because of the multi-line string.
if (process.version.match(/^v(\d+\.\d+)/)[1] < 4) {
  outputError('Please upgrade your NodeJS to >= 4.');
  process.exit(1);
}

var usageInfo = `
Usage:

  cat file.csv | ./${self} [options] [place uuid]

Description:

  Create data using the /api/v1 API, requires webapp version 2.6.2 or later.
  Returns errors and is silent on success.

  This script supports multiple record types and you must specify what type
  with the -t flag.  Each type has its own contraints and required columns.
  The column names are mapped directly to property names on the JSON POST body.
  To understand more about the special meanings of property names see the
  medic-api documentation.

  Column names that begin with \`place.\` or \`contact.\` are handled
  specially.  This allows you to specify custom properties on the contact or
  place objects that are associated with the data.  For example if you define a
  column labeled \`place.supervisor\`, then the values in those cells are set
  on the \`supervisor\` property of the place object during user creation.

Options:

  -t  Record type. Currently supported types: users, people, places-level-n
  -d  Dry run, only prints request body.
  -i  Comma separated list of column names to ignore.
  -h  This help information

Environment Variables:

  COUCH_URL
  
    Specifies the URL of the project.

    Example:

      export COUCH_URL=https://admin:secret@project.app.medicmobile.org

Examples:

  Users import dry run:

    cat 'Group 2 Tula.csv' | ./${self} -t users -d

  Users import dry run with a place (district/branch) identifier:

    cat 'Group 2 Tula.csv' | \\
      ./${self} -t users -d 8fe84af17cb7ac863a92e884e50440c3

  Users import:

    cat 'Group 2 Tula.csv' | \\
      ./${self} -t users 8fe84af17cb7ac863a92e884e50440c3

  Use head command to only create first record:

    head -2 'Group 2 Tula.csv' | \\
      ./${self} -t users 8fe84af17cb7ac863a92e884e50440c3

  Import people:

    cat 'Supervisors.csv' | \\
      ./${self} -t people 8fe84af17cb7ac863a92e884e50440c3

  Import people and ignore the concession and gender columns:

    cat 'Supervisors.csv' | \\
      ./${self} -t people -i concession,gender 8fe84af17cb7ac863a92e884e50440c3

`;

var usage = function() {
  console.info(usageInfo);
  process.exit(1);
};

if (process.argv.indexOf('-h') !== -1) {
  usage();
}

if (process.argv.indexOf('-d') !== -1) {
  flags.dryrun = true;
  process.argv.splice(process.argv.indexOf('-d'), 1);
}

if (process.argv.indexOf('-t') !== -1) {
  flags.recordType = process.argv.splice(process.argv.indexOf('-t'), 2)[1];
  if (!supportedTypes[flags.recordType]) {
    throw new Error('Record type not supported: ' + flags.recordType);
  }
} else {
  usage();
}

if (process.argv.indexOf('-i') !== -1) {
  flags.ignoreColumns = process.argv.splice(
    process.argv.indexOf('-i'), 2
  )[1].split(',');
}

if (process.env.COUCH_URL) {
  reqOpts = url.parse(process.env.COUCH_URL);
} else {
  usage();
}

if (reqOpts.protocol === 'https:') {
  console.info('using https module');
  http = require('https');
}

var placeUUID = process.argv[2],
    indexes = {};

var recordStat = function(obj) {
  var resCode = obj.statusCode;
  if (resCode) {
    if (typeof stats.responses[resCode] === 'undefined') {
      stats.responses[resCode] = 0;
    }
    stats.responses[resCode]++;
  }
};

var validate = function(obj, cb) {
  var config = supportedTypes[flags.recordType];
  config.required.forEach(function(field) {
    if (typeof obj[field] === 'undefined') {
      throw new Error('Missing required field: ' + field);
    }
  });
  if (config.constraints && config.constraints.unique) {
    config.constraints.unique.forEach(function(col) {
      if (!indexes[col]) {
        indexes[col] = {};
      }
      if (indexes[col][obj[col]]) {
        throw new Error('Failed unique constraint: ' + col + ' ' + obj[col]);
      } else {
        indexes[col][obj[col]] = 1;
      }
    });
  }
  cb(null, obj);
};

var importUser = function(obj) {
  var user = {
    username: obj.username,
    password: obj.password,
    type: obj.type || 'district-manager',
    language: obj.lang || 'en',
    known: typeof obj.known === 'undefined' ? true: Boolean(obj.known),
    external_id: obj.external_id,
    contact: {
      name: obj.name,
      phone: obj.phone
    },
    place: {
      name: obj.name + ' Area',
      type: 'health_center',
      parent: placeUUID
    }
  };
  // support `contact` or `place` properties
  Object.keys(obj).forEach(function(key) {
    var prop;
    if (key.match(/^place\.\w+/)) {
      prop = key.split('.')[1];
      if (prop === 'uuid') {
        user.place._id = obj[key];
      } else {
        user.place[prop] = obj[key];
      }
    } else if (key.match(/^contact\.\w+/)) {
      prop = key.split('.')[1];
      if (prop === 'uuid') {
        user.contact._id = obj[key];
      } else {
        user.contact[prop] = obj[key];
      }
    }
  });
  setTimeout(function() {
    reqOpts.method = 'POST';
    reqOpts.path = '/api/v1/users';
    reqOpts.headers = {
      'content-type': 'application/json'
    };
    if (flags.dryrun) {
      console.log(reqOpts.method, reqOpts.path);
      return console.log(JSON.stringify(user, null, 2));
    }
    stats.requests++;
    var req = http.request(reqOpts, function(res) {
      recordStat(res);
      if (res.statusCode != 200 && res.statusCode != 201) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
          outputError('  ' + chunk);
        });
        return outputError(
          'failed to import user %s status %s %s:',
          obj.username,
          res.statusCode,
          res.statusMessage
        );
      }
    });
    req.on('error', function(e) {
      if (e) throw e;
    });
    req.write(JSON.stringify(user));
    req.end();
  }, stats.rows * wait);
};

var importPerson = function(obj) {
  var config = supportedTypes[flags.recordType],
      person = {};
  Object.keys(obj).forEach(function(k) {
    if (k === 'uuid') {
      person._id = obj[k];
    } else if (flags.ignoreColumns.indexOf(k) === -1) {
      person[k] = obj[k];
    }
  });
  // support values on `place.foo` columns
  Object.keys(obj).forEach(function(key) {
    var prop;
    if (key.match(/^place\.\w+/)) {
      prop = key.split('.')[1];
      if (prop === 'uuid') {
        person.place._id = obj[key];
      } else {
        person.place[prop] = obj[key];
      }
    }
  });
  if (Object.keys(person.place).length === 0) {
    person.place = obj.place || placeUUID;
  }
  person.type = config.doc_type;
  setTimeout(function() {
    reqOpts.method = 'POST';
    reqOpts.path = '/api/v1/people';
    reqOpts.headers = {
      'content-type': 'application/json'
    };
    if (flags.dryrun) {
      console.log(reqOpts.method, reqOpts.path);
      return console.log(JSON.stringify(person, null, 2));
    }
    stats.requests++;
    var req = http.request(reqOpts, function(res) {
      recordStat(res);
      if (res.statusCode != 200 && res.statusCode != 201) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
          outputError('  ' + chunk);
        });
        return outputError(
          'failed to import person %s status %s %s:',
          obj.name,
          res.statusCode,
          res.statusMessage
        );
      }
    });
    req.on('error', function(e) {
      if (e) throw e;
    });
    req.write(JSON.stringify(person));
    req.end();
  }, stats.rows * wait);
};

var importPlace = function(obj) {
  var config = supportedTypes[flags.recordType],
      place = {
        parent: obj.parent || placeUUID
      };
  Object.keys(obj).forEach(function(k) {
    if (k === 'uuid') {
      place._id = obj[k];
    } else if (flags.ignoreColumns.indexOf(k) === -1) {
      place[k] = obj[k];
    }
  });
  // support `parent` and `contact` properties
  Object.keys(obj).forEach(function(key) {
    var prop;
    if (key.match(/^contact\.\w+/) || key.match(/^parent\.\w+/)) {
      prop = key.split('.')[1];
      place[key][prop] = obj[key][prop];
    }
  });
  place.type = config.doc_type;
  setTimeout(function() {
    reqOpts.method = 'POST';
    reqOpts.path = '/api/v1/places';
    reqOpts.headers = {
      'content-type': 'application/json'
    };
    if (flags.dryrun) {
      console.log(reqOpts.method, reqOpts.path);
      return console.log(JSON.stringify(place, null, 2));
    }
    stats.requests++;
    var req = http.request(reqOpts, function(res) {
      recordStat(res);
      if (res.statusCode != 200 && res.statusCode != 201) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
          outputError('  ' + chunk);
        });
        return outputError(
          'failed to import place %s status %s %s:',
          obj.name,
          res.statusCode,
          res.statusMessage
        );
      }
    });
    req.on('error', function(e) {
      if (e) throw e;
    });
    req.write(JSON.stringify(place));
    req.end();
  }, stats.rows * wait);
};

if (flags.recordType === 'users') {
  importer = importUser;
} else if (flags.recordType === 'people') {
  importer = importPerson;
} else if (flags.recordType.match(/places-level-\d/)) {
  importer = importPlace;
}

var onDataHandler = function(obj) {
  stats.rows++;
  importer(obj);
};

csv
  .fromStream(process.stdin, {headers:true})
  .validate(validate)
  .on('data', onDataHandler)
  .on('end', function() {
    console.info(
      'processing %s rows, will take about %s minutes.',
      stats.rows,
      (((stats.rows * wait)/1000) / 60).toFixed(1)
    );
  });

var responsesContainErrors = function(responses) {
  return Object.keys(responses).some(function(key) {
    return !key.startsWith('2');
  });
};

process.on('exit', function() {
  console.info('');
  console.info(stats);
  if (stats.responses && responsesContainErrors(stats.responses)) {
    outputError('IMPORTANT: Some errors occured during this import, please read the output above!');
  }
});
